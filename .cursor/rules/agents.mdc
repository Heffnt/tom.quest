---
description: Project context for tom.Quest - UPDATE THIS FILE after any changes or fixes
alwaysApply: true
---

# tom.Quest

**AGENT REQUIREMENT: After ANY code change, add/update relevant info here. After ANY bug fix, add to Fixes section. This prevents repeated mistakes and keeps context accurate.**

## Rules
- always commit after making changes
- always style the site name as tom.Quest
- avoid number input spinners; use text inputs for numeric intervals

## Stack
Next.js 16 (App Router) | TypeScript | Tailwind v4 (PostCSS) | Poppins font | Vercel | Supabase (Auth + DB)

## Design
- Font: Poppins via `--font-app` in `app/layout.tsx`
- Colors: black bg, white text (60%/40% opacity for secondary)
- Layout: max-w-3xl mx-auto, px-6 py-16, min-h-screen
- Animations: animate-fade-in, animate-fade-in-delay (globals.css)
- Logos: `public/images/` (SVG: logo-{black,white}-{on-black,on-white,transparent}.svg, PNG symbols: symbol-*)
- Favicon: `app/icon.png` (symbol-white-on-black.png)
- Landing page + nav: logo-white-transparent.svg

## Structure
```
app/
├── turing/page.tsx          # GPU dashboard (multi-user, read-only for guests)
├── chat-tom/page.tsx        # Tom's chat dashboard (Tom only)
├── api/
│   ├── turing/              # Proxy routes → user's or Tom's Turing backend
│   │   ├── connection/      # GET/POST/DELETE user Turing connection
│   │   └── ...              # gpu-report, allocate, jobs, dirs, sessions
│   ├── chat/                # Chat system API
│   │   ├── devices/         # GET/POST devices, [id] for details
│   │   ├── messages/        # GET/POST messages
│   │   └── track/           # POST page visits
│   └── auth/is-tom/         # POST verify if user is Tom
├── components/
│   ├── AuthProvider.tsx     # Auth context (user, profile, isTom, turingConnection)
│   ├── LoginModal.tsx       # Sign in/up modal
│   ├── ChatBubble.tsx       # Floating chat + login buttons
│   ├── ChatInterface.tsx    # Chat modal
│   ├── DeviceTracker.tsx    # Device registration + page tracking
│   ├── ClientProviders.tsx  # Wraps auth/chat in layout
│   └── Navigation.tsx       # Nav with conditional Tom links
└── lib/
    ├── supabase.ts          # Supabase client + types
    └── turing.ts            # Turing URL resolution (Tom's gist or user's connection)

tom-quest-api/               # FastAPI on Turing HPC
├── main.py, gpu_report.py, slurm.py, tmux.py, dirs.py, job_screens.py
```

## Auth & Chat System
- Supabase Auth: email/password signup/signin
- Env: `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, `SUPABASE_SERVICE_KEY`, `TOM_USER_ID`
- Tom identified by `TOM_USER_ID` env var matching Supabase user ID
- DB tables: `profiles`, `devices`, `messages`, `page_visits`, `turing_connections`
- Device tracking: UUID in localStorage, UA parsing via `ua-parser-js`, tracks page visits + duration
- ChatBubble: floating top-left, "Tell Tom something!" + login/user icon
- Chat (Tom) page: visible only to Tom, shows all devices, conversations, device info modal
- Polling: chat polls every 5s when open

## Multi-User Turing
- Guests/non-connected users: view Tom's dashboard (read-only)
- Logged-in users can connect their own Turing backend (tunnel URL)
- Connection verified by hitting `/health` endpoint before saving
- API routes check `x-user-id` header, proxy to user's URL or Tom's
- Write endpoints (allocate, cancel, dirs) require own connection or Tom
- Read endpoints (gpu-report, jobs, sessions output) allowed for all

## Turing Dashboard
- Proxy: frontend → /api/turing/* → Turing backend (via Cloudflare quick tunnel)
- URL discovery: API auto-updates GitHub Gist → Vercel reads from `TURING_URL_GIST` (1min cache TTL)
- After API restart: expect ~1-2min of 530 errors while tunnel establishes + caches refresh
- Auth: X-API-Key header (TURING_API_KEY on Vercel, API_KEY on Turing)
- Turing .env: API_KEY, GITHUB_TOKEN (gist scope), GIST_ID
- Vercel env: TURING_URL_GIST (raw gist url), TURING_API_KEY
- GPUs: nvidia=H100, tesla=V100, max 12 allocations
- GPU Report API: returns `{nodes: NodeInfo[], summary: {free, available, unavailable}}`
  - NodeInfo: `{name, gpu_type, partition, total_gpus, allocated_gpus, state, memory_total_mb, memory_allocated_mb}`
  - state: "up" | "down" | "drain"
- GPU Visual Grid: partition → GPU type hierarchy, collapsible partitions, SVG boxes per GPU (green=free, gray=in use, red=down), memory bar per node
- GPU type labels: "nvidia (H100)", "tesla (V100)"
- Allocation: --job-name=tom.quest, non-blocking salloc, default 1440 mins
- tmux sessions: `{project_name}_{index}` (1-indexed), polls until RUNNING then creates tmux session + srun + commands
- Session mapping: `~/.tom-quest-screens.json` stores job_id → session_name (jobs without mapping show "-")
- Session viewer: "View" button on running jobs → modal with tmux output, auto-refresh toggle (configurable interval, persisted), arrow navigation between sessions, click-outside-to-close
- SSH attach: `tmux attach -t {session_name}`, detach with `Ctrl+b d`
- localStorage: `turing_project_commands`, `turing_auto_refresh`, `turing_refresh_interval`, `turing_collapsed_partitions`, `turing_gpu_only_filter`, `turing_session_auto_refresh`, `turing_session_refresh_interval`
- Auto-refresh: unified at top for all panels, configurable interval (default 30s) via text input, each panel has own refresh button
- Job status: shows squeue reason in parens (e.g. "PENDING (Resources)", "RUNNING (gpu-21)")
- Dir browse: always sends path (default `~`), surfaces upstream error
- Turing setup: clone repo to `~/tom.quest`, use `tom-quest-api/` subdir
- Allocate panel: GPU types from non-academic partitions with `gpu` node names; blank count allocates all free (up to 12)
- GPU availability totals and legend counts reflect only visible (non-collapsed) partitions
- Active Jobs: cancel-all button with confirm modal

## Fixes & Lessons
<!-- Add entries: [date] issue → fix -->
- [2026-01-28] /api/turing/dirs 404 without path → default to `~`, show upstream error
- [2026-01-29] Cloudflare 524/HTML responses → auto-start tunnel + file logs in API
- [2026-01-29] salloc timeout on resource wait → non-blocking Popen, capture job ID from early output, screen polls for RUNNING before commands
- [2026-01-29] Active Jobs showed wrong screen name → added job_screens.py mapping file, simplified screen names to `{project}_{index}`, external jobs show "-"
- [2026-01-29] 530 errors after API restart → transient: wait ~1-2min for new tunnel + gist update + Vercel cache (1min TTL) to refresh
- [2026-01-29] Multi-GPU allocation got same screen name → get_next_screen_name now checks both screen processes AND job_screens mapping
- [2026-01-29] srun failed on PENDING job → poll for RUNNING first, then create screen and send srun
- [2026-01-29] Screen names 1-indexed, job status shows squeue reason, unified auto-refresh controls at top
- [2026-01-29] Debug terminal: resizable (drag header), dynamic bottom padding, copy button, fixed hover transparency
- [2026-01-29] GPU Availability: visual SVG grid with per-node GPU boxes + memory bars, API returns per-node data instead of aggregates
- [2026-01-29] GPU grid: partition hierarchy, collapsible sections (localStorage), gpu-only filter toggle, removed notes (replaced by implemented features)
- [2026-01-30] Replaced GNU screen with tmux: better VSCode scrolling, session output viewable from web via `tmux capture-pane`
- [2026-02-02] Proxy fetch failures after tunnel changes → retry once with forced gist refresh
- [2026-02-02] Proxy fetch failed had no cause info → validate gist URL, surface fetch cause details
- [2026-02-02] Cloudflare 530 after restart → force gist refresh + retry on 530
- [2026-02-02] Session indices never reset → `get_active_mapped_screens()` only reserves indices for jobs still in queue, not historical mappings
- [2026-02-02] Added auth + chat system: Supabase Auth, device tracking, chat bubble, Tom's dashboard
- [2026-02-02] Added multi-user Turing: users can connect own backend, read-only mode for guests
- [2026-02-02] ua-parser-js import fix: use named export `{ UAParser }` not default

## Placeholders
- /projects: showcase work
- /data-labeling: annotation tools
